from langchain_core.runnables.config import RunnableConfig
from pydantic import BaseModel, Field, model_validator
from typing import List, Dict

from dataqa.llm.openai import AzureOpenAI
from dataqa.memory import Memory
from dataqa.utils.prompt_utils import build_prompt, prompt_type
from dataqa.utils.langgraph_utils import (
    CONFIGURABLE,
    BASE_URL,
    API_KEY,
)

prompt_example = """
As an AI assistant, your task is to infer business rules based on below information.
1. User question
2. Generated SQL query by LLM based on Schema and User question
3. Expected ground truth SQL generated by analyst with domain knowledge of business rules

By comparing generated SQL and expected SQL, you can determine if additional business rules are needed.

User question:
What is the total gross sales volume by MOP code for co_id 1003 for the month of Jan 2025?

Generated SQL:
SELECT 
    MOP_CD, 
    SUM(GROSS_SALES_USD) AS total_gross_sales_usd
FROM PROD_BD_TH_FLAT_V3
WHERE CO_ID = '1003'
  AND SUBM_DT_YYYYMM = 202501
GROUP BY MOP_CD;

Expected SQL
SELECT co_id, CASE WHEN mop_cd in ('VI','VR','CR','CZ') THEN 'VI' WHEN mop_cd in ('MC','MR') THEN 'MC' WHEN mop_cd in ('DI','DD','JC') THEN 'DI' ELSE mop_cd END brand, sum(gross_sales_usd) as gross_sales_usd
FROM PROD_BD_TH_FLAT_V3
WHERE co_id in ('1003') AND subm_dt_yyyymm in  ('202501')
GROUP BY co_id, brand;

Please start comparing and reasoning, and infer business rules.
"""


rule_inference_prompt_template = """
As an AI assistant, your task is to infer business rules based on below information.
1. User question
2. Generated SQL query by LLM based on Schema and User question
3. Expected ground truth SQL generated by analyst with domain knowledge of business rules

Business rules are defined as follows:
- It is generic and applies to all different queries about the same table
- It is abstract, and not focused on specific renamed columns

Example of good business rule:
- When querying for MOP code, group similar MOP codes ('VI', 'VR', 'CR', 'CZ') under a single brand 'VI'.
- Always include 'co_id' in the SELECT and GROUP BY clauses when filtering by 'co_id'.

Example of bad business rule:
- The query must include a filter for CUST_COUNTRY_CD to be either 'US' or 'USA'.
To make above rule more generic and specific, convert it to:
- when querying region of us, filter on CUST_COUNTRY_CD in ('US', 'USA')

By comparing generated SQL and expected SQL, you can determine if additional business rules are needed.

User question: {query}

Generated SQL:
{generated_sql}

Expected SQL:
{expected_sql}

Please start comparing and reasoning, and infer business rules."""


rule_consolidation_prompt_template = """
As an AI assistant, you are given a list of business rules that are used to generate SQL queries. Your task is to combine list of business rules following below instructions.
1. If two rules are the same, combine them into one rule
2. If two rules are similar, create a new rule that covers both of them
3. If two rules are different, keep both of them.

List of business rules:
{rule_list_str}

Please consolidate business rules. The output should be a list of consolidated business rules. 
A consolidated business rule contains the rule description and a list of rule indexes that the rule is extracted from.
"""


rule_pruning_prompt_template = """
As an AI assistant, you are given a list of business rules that are used to generate SQL queries. Your task is to identify which rules are triggered in a given example of question, and expected SQL.

List of business rules:
{rule_list_str}

Example:
User question:
{query}

Expected SQL
{expected_sql}

Please analyze the example, and identify which rule is triggered to generate the SQL.
"""


class Rules(BaseModel):
    """The rules extracted"""

    rules: List[str] = Field(
        default_factory=list, description="A list of rules"
    )


class IndexedRules(BaseModel):
    """The indices of rules"""

    rules: List[str] = Field(
        default_factory=list, description="A list of rule indices"
    )


class ConsolidatedRule(BaseModel):
    """The consolidated rule"""

    rule: str = Field(description="rule description")
    source: List[str] = Field(
        default_factory=list, description="A list rule indexes that the rule is extracted from"
    )


class ConsolidatedRules(BaseModel):
    """The consolidated rules"""

    rules: List[ConsolidatedRule] = Field(
        default_factory=list, description="A list of consolidated rules"
    )



class RuleInference:
    """
    Inference business rule by comparing ground truth query and generated query

    Input:
        question: str
        ground_truth_query: str
        generated_query: str
    Output:
        rule: Rule
    """

    name = "rule_inference"
    num_reties: int = 5

    def __init__(self, llm: AzureOpenAI, prompt: prompt_type):
        self.prompt = build_prompt(prompt)
        self.llm = llm

    async def __call__(self,
                       query: str,
                       generated_sql: str,
                       expected_sql: str,
                       config: RunnableConfig):
        """
        Inference business rule by comparing ground truth query and generated query

        :param query: User question
        :param generated_sql: Generated SQL query
        :param expected_sql: Ground truth SQL query
        :param config: Config for the inference
        :return: A list of rules
        """
        messages = self.prompt.invoke(dict(query=query, generated_sql=generated_sql, expected_sql=expected_sql))
        api_key = config.get(CONFIGURABLE, {}).get(API_KEY, "")
        base_url = config.get(CONFIGURABLE, {}).get(BASE_URL, "")

        responses = []
        for _ in range(self.num_reties):
            response = await self.llm.ainvoke(
                messages=messages,
                api_key=api_key,
                base_url=base_url,
                from_component=self.name,
                with_structured_output=Rules,
            )
            responses.append(response)
            rules = response.generation
            if isinstance(rules, Rules):
                break
        if not isinstance(rules, Rules):
            raise Exception("Failed to extract rules.")
        return dict(rules=[rules], llm_output=responses)


class RuleConsolidation:
    """
    Consolidate list of rules by combining duplicate or similar rules
    """

    name = "rule_consolidation"
    num_reties: int = 5

    def __init__(self, llm: AzureOpenAI, prompt: prompt_type):
        self.prompt = build_prompt(prompt)
        self.llm = llm

    async def __call__(self,
                       rule_list_str: str,
                       config: RunnableConfig):
        """
        """
        messages = self.prompt.invoke(dict(rule_list_str=rule_list_str))
        api_key = config.get(CONFIGURABLE, {}).get(API_KEY, "")
        base_url = config.get(CONFIGURABLE, {}).get(BASE_URL, "")

        responses = []
        for _ in range(self.num_reties):
            response = await self.llm.ainvoke(
                messages=messages,
                api_key=api_key,
                base_url=base_url,
                from_component=self.name,
                with_structured_output=ConsolidatedRules,
            )
            responses.append(response)
            rules = response.generation
            if isinstance(rules, ConsolidatedRules):
                break
        if not isinstance(rules, ConsolidatedRules):
            raise Exception("Failed to consolidate rules.")
        return dict(rules=[rules], llm_output=responses)


class RuleTriggered:
    """
    Identifying which rules are triggered in a given example of question
    """

    name = "rule_triggered"
    num_reties: int = 5

    def __init__(self, llm: AzureOpenAI, prompt: prompt_type):
        self.prompt = build_prompt(prompt)
        self.llm = llm

    async def __call__(self,
                       rule_list_str: str,
                       query: str,
                       expected_sql: str,
                       config: RunnableConfig):
        """
        """
        messages = self.prompt.invoke(dict(rule_list_str=rule_list_str,
                                           query=query,
                                           expected_sql=expected_sql))
        api_key = config.get(CONFIGURABLE, {}).get(API_KEY, "")
        base_url = config.get(CONFIGURABLE, {}).get(BASE_URL, "")

        responses = []
        for _ in range(self.num_reties):
            response = await self.llm.ainvoke(
                messages=messages,
                api_key=api_key,
                base_url=base_url,
                from_component=self.name,
                with_structured_output=IndexedRules,
            )
            responses.append(response)
            rules = response.generation
            if isinstance(rules, IndexedRules):
                break
        if not isinstance(rules, IndexedRules):
            raise Exception("Failed to identify rules.")
        return dict(rules=[rules], llm_output=responses)


rule_list_str = """
Rule-01: When querying for a specific CUST_EXTL_ID, ensure that the CUST_TYPE_CD is also specified if relevant to the query context. Split the identifier into its components and filter separately on CUST_EXTL_ID and CUST_TYPE_CD.
Rule-02: Always group by CUST_COUNTRY_CD or CUST_STATE_CD when selecting them without aggregation functions to ensure unique results per country or state.
Rule-03: Limit the results to 100 when querying for specific customer details, customer names, customer state codes, or ecid.
Rule-04: Always include a GROUP BY clause for CUST_NAME, CUST_KEY, CUST_EXTL_ID, CUST_NAME, and CUST_COUNTRY_CD when selecting these fields.
Rule-05: Rename the CUST_NAME column to 'td_name' when querying for TD type customers.
Rule-06: When querying for a specific week, use 'subm_dt_yyyymm' to filter the month and 'subm_dt' to filter the exact date range, specifying the date range from Monday to Sunday.
Rule-07: Always include 'co_id' in the SELECT and GROUP BY clauses when filtering by 'co_id'.
Rule-08: When querying for counts of TDS, use COUNT(DISTINCT cust_extl_id) to ensure unique counts.
Rule-09: Filter by 'cust_type_cd' = 'TD' when querying for TDS or ensuring the correct customer type.
Rule-10: Ensure 'cust_extl_id', 'cust_stat', CUST_KEY, CUST_NAME, and CUST_COUNTRY_CD are not NULL when performing counts, aggregations, or querying for customer details.
Rule-11: Use 'ownrshp_comp_lvl_1_extl_id' instead of 'co_id' for filtering by company ID in the EIS_D_CUST_PORTFOLIO table.
Rule-12: Limit the results to 10000 rows when performing aggregations or querying from EIS_D_CUST_PORTFOLIO to ensure performance and manageability.
Rule-13: Include a GROUP BY clause for all selected columns when querying from EIS_D_CUST_PORTFOLIO.
Rule-14: When querying for customer key using a name pattern like 'TD 666', split the pattern into 'CUST_TYPE_CD' and 'CUST_EXTL_ID'.
Rule-15: When querying for customers, always filter by CUST_STAT = 'A' to ensure active customers.
Rule-16: When querying for the US region, filter on CUST_COUNTRY_CD in ('US', 'USA').
Rule-17: When querying for ecid, use BANK_ENTERPRISE_CUST_ID as ecid in the SELECT clause.
Rule-18: Always group by BANK_ENTERPRISE_CUST_ID when selecting it.
Rule-19: When querying for MOP code, group similar MOP codes ('VI', 'VR', 'CR', 'CZ') under a single brand 'VI', ('MC', 'MR') under 'MC', and ('DI', 'DD', 'JC') under 'DI'. Use a CASE statement to map multiple MOP codes to a single brand in the SELECT clause.
Rule-20: When filtering by a specific month, use 'subm_dt_yyyymm' in the WHERE clause and include it in the GROUP BY clause if needed. Use 'subm_dt' for the specific date range.
Rule-21: Use BETWEEN for date range filtering when querying for a specific quarter.
Rule-22: When querying for sales volume, use 'SUM(GROSS_SALES_USD)' to calculate the total sales.
Rule-23: When filtering by 'td_id', use 'MBR_ENT' in the WHERE clause.
Rule-24: Always group by 'MBR_ENT' when calculating sales volume.
"""

if __name__ == "__main__":
    import os
    import asyncio
    os.environ['CERT_PATH'] = ""
    os.environ["CLIENT_ID"] = ""
    os.environ["TENANT_ID"] = ""
    os.environ["OPENAI_API_BASE"] = ""
    from scripts.azure_token import get_az_token_using_cert
    api_key = get_az_token_using_cert()[0]
    config = {
        "configurable": {
            "api_key": api_key,
            "base_url": os.environ["OPENAI_API_BASE"],
        }
    }

    llm_config = {"model": "gpt-4o-2024-08-06",
                  "api_version": "2024-08-01-preview",
                  "api_type": "azure_ad",
                  "temperature": 0,
                  "num_response": 1,
                  "azure_model_params": {"model_name": "gpt-4o"}}
    llm = AzureOpenAI(**llm_config)
    # rule_inference = RuleInference(llm=llm, prompt=rule_inference_prompt_template)
    # rules = asyncio.run(rule_inference(query="What is the total gross sales volume by MOP code for co_id 1003 for the month of Jan 2025?",
    #                        generated_sql="SELECT SUM(GROSS_SALES_USD) AS total_gross_sales_usd\nFROM PROD_BD_TH_FLAT_V3\nWHERE CO_ID = '1003'\n  AND SUBM_DT_YYYYMM = 202501\nGROUP BY MOP_CD;",
    #                        expected_sql="SELECT co_id,CASE WHEN mop_cd in ('VI','VR','CR','CZ') THEN 'VI' WHEN mop_cd in ('MC','MR') THEN 'MC' WHEN mop_cd in ('DI','DD','JC') THEN 'DI' ELSE mop_cd END brand, sum(gross_sales_usd) as gross_sales_usd\nFROM PROD_BD_TH_FLAT_V3\nWHERE co_id in ('1003') AND subm_dt_yyyymm in  ('202501')\nGROUP BY co_id, brand;",
    #                        config=config))
    # rule_consolidation = RuleConsolidation(llm=llm, prompt=rule_consolidation_prompt_template)
    # rules = asyncio.run(rule_consolidation(rule_list_str=rule_list_str,
    #                                        config=config))
    rule_triggered = RuleTriggered(llm=llm, prompt=rule_pruning_prompt_template)
    rules = asyncio.run(rule_triggered(rule_list_str=rule_list_str,
                                       query="What is the total gross sales volume by MOP code for co_id 1003 for the month of Jan 2025?",
                                       expected_sql="SELECT co_id,CASE WHEN mop_cd in ('VI','VR','CR','CZ') THEN 'VI' WHEN mop_cd in ('MC','MR') THEN 'MC' WHEN mop_cd in ('DI','DD','JC') THEN 'DI' ELSE mop_cd END brand, sum(gross_sales_usd) as gross_sales_usd\nFROM PROD_BD_TH_FLAT_V3\nWHERE co_id in ('1003') AND subm_dt_yyyymm in  ('202501')\nGROUP BY co_id, brand;",
                                       config=config)
                        )
    print(rules)
    for rule in rules["rules"][0].rules:
        print(rule)
