"""Shared state model for LangGraph-based agent orchestration."""

from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field

from ..models.document import Document
from ..models.execution import ExecutionResult
from ..models.message import Message


class SharedState(BaseModel):
    """Shared state for conversation and workflow management.
    
    This model maintains the state throughout the agent's workflow execution,
    including conversation history, retrieved context, generated code, and
    execution results. It serves as the central state container for LangGraph
    workflow orchestration.
    """
    
    # Core conversation state
    conversation_history: List[Message] = Field(
        default_factory=list,
        description="Complete conversation history between user and agent"
    )
    current_query: str = Field(
        default="",
        description="The current user query being processed"
    )
    
    # Query analysis results
    query_analysis: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Analysis results from query processing (intent, entities, etc.)"
    )
    
    # Knowledge retrieval state
    retrieved_context: List[Document] = Field(
        default_factory=list,
        description="Documents retrieved from knowledge base for current query"
    )
    context_summary: Optional[str] = Field(
        default=None,
        description="Summary of retrieved context for LLM consumption"
    )
    
    # Code generation state
    generated_code: Optional[str] = Field(
        default=None,
        description="Code generated by the LLM for the current query"
    )
    code_type: Optional[str] = Field(
        default=None,
        description="Type of generated code (sql, python)"
    )
    code_validation: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Validation results for generated code"
    )
    
    # Execution state
    execution_results: Optional[ExecutionResult] = Field(
        default=None,
        description="Results from code execution"
    )
    
    # Approval workflow state
    pending_approval: Optional[str] = Field(
        default=None,
        description="Code or operation pending human approval"
    )
    approval_granted: bool = Field(
        default=False,
        description="Whether approval has been granted for pending operation"
    )
    
    # Response formatting state
    formatted_response: Optional[str] = Field(
        default=None,
        description="Final formatted response for the user"
    )
    
    # Workflow control state
    current_step: str = Field(
        default="query_processor",
        description="Current workflow step being executed"
    )
    workflow_complete: bool = Field(
        default=False,
        description="Whether the workflow has completed successfully"
    )
    error_occurred: bool = Field(
        default=False,
        description="Whether an error occurred during workflow execution"
    )
    error_message: Optional[str] = Field(
        default=None,
        description="Error message if an error occurred"
    )
    
    # Iteration control
    iteration_count: int = Field(
        default=0,
        description="Number of workflow iterations completed"
    )
    max_iterations: int = Field(
        default=10,
        description="Maximum allowed workflow iterations"
    )
    
    # Additional metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional metadata for workflow execution"
    )
    
    def add_message(self, role: str, content: str, metadata: Optional[Dict[str, Any]] = None) -> None:
        """Add a message to the conversation history.
        
        Args:
            role: Message role (user, assistant, system)
            content: Message content
            metadata: Optional message metadata
        """
        message = Message(
            role=role,  # type: ignore
            content=content,
            metadata=metadata
        )
        self.conversation_history.append(message)
    
    def get_recent_messages(self, limit: int = 5) -> List[Message]:
        """Get recent messages from conversation history.
        
        Args:
            limit: Maximum number of recent messages to return
            
        Returns:
            List of recent messages
        """
        return self.conversation_history[-limit:] if self.conversation_history else []
    
    def reset_for_new_query(self, query: str) -> None:
        """Reset state for processing a new query.
        
        Args:
            query: The new query to process
        """
        self.current_query = query
        self.query_analysis = None
        self.retrieved_context = []
        self.context_summary = None
        self.generated_code = None
        self.code_type = None
        self.code_validation = None
        self.execution_results = None
        self.pending_approval = None
        self.approval_granted = False
        self.formatted_response = None
        self.current_step = "query_processor"
        self.workflow_complete = False
        self.error_occurred = False
        self.error_message = None
        self.iteration_count = 0
    
    def set_error(self, error_message: str) -> None:
        """Set error state for the workflow.
        
        Args:
            error_message: Description of the error that occurred
        """
        self.error_occurred = True
        self.error_message = error_message
        self.workflow_complete = True
    
    def increment_iteration(self) -> bool:
        """Increment iteration count and check if max iterations reached.
        
        Returns:
            True if max iterations not reached, False otherwise
        """
        self.iteration_count += 1
        if self.iteration_count >= self.max_iterations:
            self.set_error(f"Maximum iterations ({self.max_iterations}) reached")
            return False
        return True
    
    def is_ready_for_execution(self) -> bool:
        """Check if state is ready for code execution.
        
        Returns:
            True if generated code is available and validated
        """
        return (
            self.generated_code is not None and
            self.code_type is not None and
            self.code_validation is not None and
            self.code_validation.get("is_valid", False)
        )
    
    def requires_approval(self) -> bool:
        """Check if current operation requires human approval.
        
        Returns:
            True if approval is required
        """
        return (
            self.pending_approval is not None and
            not self.approval_granted
        )